#include <fstream>
#include <iostream>
#include <string>

using namespace std;

// This struct represents a linked list node.
struct ЭлементОдносвязногоСписка
{
    float значение;
    ЭлементОдносвязногоСписка* следующий;
};

// This struct represents a Singly Linked List data structure.
struct ОдносвязныйСписок
{
public:
    ЭлементОдносвязногоСписка* _голова = nullptr;

    ОдносвязныйСписок()
    {
    }

    ~ОдносвязныйСписок()
    {
        while (_голова)
        {
            УдалитьПоследнийУзел();
        }

        cout << "Linked list destroyed." << endl;
    }

    void ДобавитьСУчётомСортировки(float знач)
    {
        auto новыйУзел = new ЭлементОдносвязногоСписка();
        новыйУзел->значение = знач;

        if (_голова == nullptr)
        {
            _голова = новыйУзел;
            return;
        }

        auto последний = ПолучитьПоследнийЭлементЗначениеКоторогоМеньшеЧем(знач);
        if (последний)
        {
            новыйУзел->следующий = последний->следующий;
            последний->следующий = новыйУзел;
        }
        else
        {
            новыйУзел->следующий = _голова;
            _голова = новыйУзел;
        }
    }

    ЭлементОдносвязногоСписка* ПолучитьГолову()
    {
        return _голова;
    }

    ЭлементОдносвязногоСписка* ПолучитьПоследнийЭлементЗначениеКоторогоМеньшеЧем(float знач)
    {
        if (знач < _голова->значение)
        {
            return nullptr;
        }

        auto г = _голова;

        while (г->следующий != nullptr && г->следующий->значение <= знач)
        {
            г = г->следующий;
        }

        return г;
    }

    ЭлементОдносвязногоСписка* ПолучитьЗад()
    {
        if (!_голова) return nullptr;

        auto г = _голова;

        while (г->следующий != nullptr)
        {
            г = г->следующий;
        }

        return г;
    }

    bool Пуст()
    {
        return _голова == nullptr;
    }

    void УдалитьПоследнийУзел()
    {
        auto последний = ПолучитьЗад();

        if (!последний)
        {
            return;
        }
        else if (_голова == последний)
        {
            _голова = nullptr;
            delete последний;
            return;
        }

        auto предпоследнийУзел = _голова;
        while (предпоследнийУзел->следующий != последний)
        {
            предпоследнийУзел = предпоследнийУзел->следующий;
        }

        delete последний;

        предпоследнийУзел->следующий = nullptr;
    }
};

// This struct represents a Queue data structure.
struct Очередь
{
public:
    Очередь(int вместимость)
    {
        _массив = new float[вместимость];
        _колво = 0;
        _вместимость = вместимость;
    }

    ~Очередь()
    {
        delete[] _массив;
        cout << "Queue destroyed." << endl;
    }

    bool Засунуть(float знач)
    {
        if (Полна()) return false;

        вставитьБезПроверки(знач);
        return true;
    }

    float Вынуть()
    {
        if (Пуста())
        {
            throw new std::runtime_error("queue is empty");
        }

        auto переднийЭлемент = получитьПередний();

        подвинутьВнутреннийМассивВверх();

        return переднийЭлемент;
    }

    bool Пуста()
    {
        return !_колво;
    }

    bool Полна()
    {
        return _колво == _вместимость;
    }

    int ПолучитьКоличество()
    {
        return _колво;
    }

    void Отобразить()
    {
        for (auto и = 0; и < _колво; и++)
        {
            cout << _массив[и] << endl;
        }
    }

private:
    float* _массив;
    int _вместимость;
    int _колво;

    void вставитьБезПроверки(float знач)
    {
        _массив[_колво] = знач;
        _колво++;
    }

    void подвинутьВнутреннийМассивВверх()
    {
        for (int и = 0; и < _колво - 1; и++)
        {
            _массив[и] = _массив[и + 1];
        }

        _колво--;
    }

    float получитьПередний()
    {
        return _массив[0];
    }
};

// This is an entry point for an application.
int main() {
    ОдносвязныйСписок односвяз;
    int колво = 0;

    ifstream чтец("./input.txt");
    string строчка;
    while (чтец >> строчка)
    {
        колво++;
        односвяз.ДобавитьСУчётомСортировки(
            stof(строчка)
        );
    }
    чтец.close();

    cout << "Read into LinkedList." << endl;

    Очередь очередь(колво);

    auto текущийУзел = односвяз.ПолучитьГолову();
    while (1)
    {
        очередь.Засунуть(текущийУзел->значение);

        if (очередь.Полна()) break;

        текущийУзел = текущийУзел->следующий;
    }

    cout << "Copied into Queue." << endl;

    ofstream писарь("./output.txt");
    while (!очередь.Пуста())
    {
        auto число = очередь.Вынуть();
        cout << число << " ";
        писарь << число << " ";
    }
    cout << endl;
    писарь.close();
}
