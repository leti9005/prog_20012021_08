#include <fstream>
#include <iostream>
#include <string>

using namespace std;

struct ЭлементОдносвязногоСписка
{
    int значение;
    ЭлементОдносвязногоСписка* следующий;
};

// This structure represents a Singly Linked List data structure.
struct ОдносвязныйСписок
{
public:
    ЭлементОдносвязногоСписка* _голова = nullptr;

    ОдносвязныйСписок()
    {
    }

    void ДобавитьСУчётомСортировки(int знач)
    {
        auto новыйУзел = new ЭлементОдносвязногоСписка();
        новыйУзел->значение = знач;

        if (_голова == nullptr)
        {
            _голова = новыйУзел;
            return;
        }

        auto последний = ПолучитьПоследнийЭлементЗначениеКоторогоМеньшеЧем(знач);
        if (последний)
        {
            новыйУзел->следующий = последний->следующий;
            последний->следующий = новыйУзел;
        }
        else
        {
            новыйУзел->следующий = _голова;
            _голова = новыйУзел;
        }
    }

    ЭлементОдносвязногоСписка* ПолучитьГолову()
    {
        return _голова;
    }

    ЭлементОдносвязногоСписка* ПолучитьПоследнийЭлементЗначениеКоторогоМеньшеЧем(int знач)
    {
        if (знач < _голова->значение)
        {
            return nullptr;
        }

        auto г = _голова;


        while (г->следующий != nullptr && г->следующий->значение <= знач)
        {
            г = г->следующий;
        }

        return г;
    }

    ЭлементОдносвязногоСписка* ПолучитьЗад()
    {
        auto г = _голова;

        while (г->следующий != nullptr)
        {
            г = г->следующий;
        }

        return г;
    }

    ЭлементОдносвязногоСписка* ЭлементНа(int позиция)
    {
        auto г = _голова;
        if (позиция == 0) return г;

        int и = 0;
        while (и != позиция && г->следующий != nullptr)
        {
            г = г->следующий;
            и++;
        }

        return г;
    }

    bool Пуст()
    {
        return _голова == nullptr;
    }

    void УдалитьПоследнийУзел()
    {
        auto последний = ПолучитьЗад();

        if (_голова == последний)
        {
            _голова = nullptr;
            delete последний;
            return;
        }

        auto предпоследнийУзел = _голова;
        while (предпоследнийУзел->следующий != последний)
        {
            предпоследнийУзел = предпоследнийУзел->следующий;
        }

        delete последний;

        предпоследнийУзел->следующий = nullptr;
    }
};

// This structure represents a Queue data structure.
struct Очередь
{
public:
    Очередь(int вместимость)
    {
        _мас = new int[вместимость];

        _колво = 0;

        _вместимость = вместимость;
    }

    ~Очередь()
    {
        delete[] _мас;
    }

    bool Засунуть(int знач)
    {
        if (Полна()) return false;

        вставитьБезПроверки(знач);
        return true;
    }

    int Вынуть()
    {
        if (Пуста())
        {
            throw new std::runtime_error("queue is empty");
        }

        auto frontElement = получитьПередний();

        подвинутьВнутреннийМассивВверх();

        return frontElement;
    }

    bool Пуста()
    {
        return !_колво;
    }

    bool Полна()
    {
        return _колво == _вместимость;
    }

    int ПолучитьКоличество()
    {
        return _колво;
    }

    void Отобразить()
    {
        for (auto и = 0; и < _колво; и++)
        {
            cout << _мас[и] << endl;
        }
    }

private:
    int* _мас;
    int _вместимость;
    int _колво;

    void вставитьБезПроверки(int знач)
    {
        _мас[_колво] = знач;
        _колво++;
    }

    void подвинутьВнутреннийМассивВверх()
    {
        for (int i = 0; i < _колво - 1; i++)
        {
            _мас[i] = _мас[i + 1];
        }

        _колво--;
    }

    int получитьПередний()
    {
        return _мас[0];
    }
};

// This is an entry point for an application.
int main() {
    ОдносвязныйСписок односвяз;
    int колво = 0;

    ifstream чтец("./input.txt");
    string строчка;
    while (чтец >> строчка)
    {
        колво++;
        односвяз.ДобавитьСУчётомСортировки(
            stoi(строчка)
        );
    }
    чтец.close();

    cout << "Read into LinkedList successfully." << endl;

    Очередь очередь(колво);

    auto текущийУзел = односвяз.ПолучитьГолову();
    while (1)
    {
        очередь.Засунуть(текущийУзел->значение);

        if (очередь.Полна()) break;

        текущийУзел = текущийУзел->следующий;
    }

    cout << "Copied into Queue successfully." << endl;

    ofstream писарь("./output.txt");
    while (!очередь.Пуста())
    {
        auto число = очередь.Вынуть();
        cout << число << " ";
        писарь << число << " ";
    }
    cout << endl;
    писарь.close();
}
